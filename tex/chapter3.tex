\chapter{روش تحقیق}\label{chapter3}

\section{تعریف بهترین آزمایه کاندید}

همان‌طور که در فصل ۲ اشاره شد، تاکنون نقطه اشتراک همه روش‌های اجرایی الگوریتم آزمون تصادفی تطبیقی در ارائه یک راهکار جهت ارزیابی آزمایه‌های مجموعه کاندید برای انتخاب بهترین (متفاوت‌ترین) آزمایه بوده است. روشی که در این پایان‌نامه ارائه خواهد شد نیز از این اصل پیروی می‌کند. در این پژوهش، روشی جدید جهت ارزیابی آزمایه‌های مجموعه کاندید ارائه می‌شود که در آن، هر آزمایه با توجه به مؤلفه‌هایی که از اجرای الگوریتم به دست می‌آید، ارزیابی شده و متفاوت‌ترین آزمایه انتخاب می‌شود.

معیار ارزیابی آزمایه‌ها در این روش بر اساس رفتارهای متفاوتی که توابع\LTRfootnote{Functions} و حلقه‌ها (عناصر تکرارشونده درون برنامه‌ها) در برنامه تحت آزمون از خود نشان می‌دهند، تعیین می‌شود. بسته به تعریف رفتار برای توابع و حلقه‌ها، می‌توان معیارهای ارزیابی متفاوتی ارائه کرد. به‌طور کلی، روال الگوریتم پیشنهادی به این صورت است که رفتارهای توابع و حلقه‌ها در حین اجرای هر آزمایه رصد می‌شوند. سپس بر اساس رفتارهایی که این آزمایه مشاهده می‌کند، به آن امتیاز داده می‌شود. هرچه رفتارهایی که توسط آزمایه کاندید مشاهده می‌شود جدیدتر باشد (یعنی رفتاری که تاکنون در آزمایه‌های انتخاب‌شده قبلی مشاهده نشده یا تعداد کمی مشاهده شده است)، امتیاز بیشتری به آن تعلق می‌گیرد. در نهایت، از میان آزمایه‌های موجود در مجموعه کاندید، آزمایه‌ای که بیشترین امتیاز را کسب کرده باشد، انتخاب خواهد شد و رفتارهای مشاهده‌شده توسط آن آزمایه به مجموعه رفتارهای مشاهده‌شده توسط آزمایه‌های انتخاب‌شده اضافه می‌شود.

\section{تعریف رفتار}

یکی از نکات کلیدی در تعریف رفتار این است که تعداد رفتارهای مختلفی که یک تابع یا حلقه در هر بار اجرای خود می‌تواند از خود بروز دهد، باید متناهی باشد. دلیل این امر این است که رفتارهای مشاهده‌شده توسط آزمایه‌های قبلی برای انتخاب آزمایه‌های جدید در الگوریتم ذخیره می‌شوند. این رفتارها به عنوان معیار برای ارزیابی آزمایه‌های کاندید استفاده می‌شوند تا مشخص شود کدام آزمایه رفتارهای جدیدتری را در برنامه تحت آزمون کشف کرده است. اگر تعداد این رفتارها متناهی نباشد، میزان فضای مورد نیاز برای ذخیره‌سازی این مجموعه رفتارها نامتناهی خواهد شد و در نتیجه عملکرد الگوریتم تحت تأثیر قرار می‌گیرد.

\subsection{اهمیت رفتار در توابع و حلقه‌ها}

توابع درون یک برنامه ممکن است بارها از مکان‌های مختلف در کد برنامه فراخوانی شوند، به همین دلیل آن‌ها به عنوان عناصر تکرارشونده در برنامه در نظر گرفته می‌شوند. این توابع معمولاً بخش‌های مهمی از فرآیندهای اجرایی برنامه را تشکیل می‌دهند. ایده اصلی روشی که در این پایان‌نامه مطرح شده است، از اینجا نشأت می‌گیرد که تفاوت بین آزمایه‌ها در واقع در حین اجرای آن‌ها مشخص می‌شود. به بیان ساده‌تر، هرچه تفاوت بین آزمایه‌ها بیشتر باشد، بخش‌های متفاوت‌تری از کد برنامه تحت آزمون را تحت تأثیر قرار می‌دهند و در نتیجه برنامه تحت آزمون رفتار متفاوت‌تری از خود نشان می‌دهد. از آنجایی که رفتار برنامه وابسته به رفتار توابعی است که درون آن اجرا می‌شوند، برای اندازه‌گیری میزان تفاوت بین آزمایه‌ها، رفتارهای مختلفی که توابع در حین اجرای هر آزمایه از خود نشان می‌دهند، بررسی می‌شود.

با این حال، از آنجایی که باید تعداد رفتارهایی که برای توابع تعریف می‌شود متناهی باشد، و از طرفی حلقه‌های درون توابع ممکن است در هر بار اجرای خود رفتار متفاوتی از خود بروز دهند، بررسی رفتارهای حلقه‌ها به صورت مجزا نیز اهمیت پیدا می‌کند. این کار باعث می‌شود که هم رفتارهای مختلفی که هر حلقه از خود نشان می‌دهد مورد بررسی قرار گیرد و هم تعداد رفتارهایی که توابع شامل حلقه‌ها دارند، نامتناهی نشود.

\subsection{انواع مختلف تعریف رفتار}

رفتار در واقع ترتیب عملیات‌هایی است که یک عنصر تکرارشونده در طول زمان اجرای خود انجام می‌دهد. این عملیات‌ها می‌تواند شامل اجرای دیگر عناصر تکرارشونده، پوشش یا عدم پوشش شرط‌های درون کد برنامه، مقداردهی به متغیرها، استفاده از مقادیر متغیرها و موارد مشابه باشد. اما باید به این نکته توجه داشت که هرچه عملیات‌های بیشتری را در تعریف رفتار بگنجانیم، تعداد رفتارهایی که عناصر تکرارشونده برنامه خواهند داشت بیشتر خواهد شد که این امر باعث افزایش هزینه زمانی و فضایی الگوریتم آزمون تصادفی تطبیقی پیشنهادی می‌شود. در ادامه به بررسی چند روش پیاده‌سازی آزمون تصادفی تطبیقی خواهیم پرداخت که تنها تفاوت آن‌ها در تعریف رفتار عناصر تکرارشونده است.

\subsubsection{روش \lr{ART\_AutoISP}}

در این روش، تعریف رفتار به این صورت است که هر ترتیب جدید از فراخوانی و اجرای دیگر عناصر تکرارشونده درون کد برنامه تحت آزمون به عنوان یک رفتار جدید برای آن عنصر تکرارشونده در نظر گرفته می‌شود. در ادامه با ذکر یک مثال روی یک نمونه کوچک، این روش به صورت کامل توضیح داده می‌شود.

%\subsubsection{توضیح روش با استفاده از مثال }
فرض کنید که برای کد زیر، با استفاده از روش \lr{ART\_AutoISP} تعدادی آزمایه انتخاب کرده‌ایم. این کد وظیفه محاسبه مقدار یک عبارت ریاضی را که به صورت رشته داده شده است، بر عهده دارد.
\newpage
\begin{figure}[!h]
	\begin{LTR}
		\singlespacing
		\lstinputlisting[language=Python, caption={\footnotesize کد پایتون برای محاسبه یک عبارت ریاضی}, label={code:pythonEx}]{python.py}
		% \doublespacing
	\end{LTR}
\end{figure}

فرض کنید رفتارهای زیر تاکنون توسط آزمایه‌های انتخاب شده مشاهده شده است:

\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			 evaluate &  \texttt{\lr{[evaluate.loop<line 6> $\rightarrow$ evaluate.loop<line 28>]}} &  \lr{10} \\
			\hline
			\multirow{5}{*}{ \lr{evaluate.loop<line 6>}} &  \texttt{\lr{[]}} &  \lr{45}  \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.loop<line 14>]}} &  \lr{12} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.loop<line 20>]}} &  \lr{15} \\
			\cline{2-3}
			&  \texttt{\lr{[precedence $\rightarrow$ precedence]}} &  \lr{17} \\
			\cline{2-3}
			&  \texttt{\lr{[precedence $\rightarrow$ precedence $\rightarrow$ evaluate.loop<line 24>]}} &  \lr{11} \\
			\hline
			 \lr{evaluate.loop<line 14>} &  \texttt{\lr{[]}} & \lr{48} \\
			\hline
			\lr{evaluate.loop<line 20>} &  \texttt{\lr{[process]}} & \lr{39} \\
			\hline
			\lr{evaluate.loop<line 24>} &  \texttt{\lr{[process]}} & \lr{23} \\
			\hline
			\lr{evaluate.loop<line 28>} &  \texttt{\lr{[process]}} & \lr{40} \\
			\hline
			\lr{precidence} &  \texttt{\lr{[]}} & \lr{56} \\
			\hline
			\lr{process} &  \texttt{\lr{[apply\_operation]}} & \lr{104} \\
			\hline
			\lr{apply\_operation} &  \texttt{\lr{[]}} & \lr{104} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه‌های انتخاب‌شده قبلی در روش \lr{ART\_AutoISP}}
\end{table}

\begin{itemize}
	\item \textbf{تولید آزمایه‌های کاندید}

برای انتخاب آزمایه جدید باید چند آزمایه کاندید جدید تولید شوند تا از بین این آزمایه‌ها بهترین آزمایه انتخاب شود.

فرض کنید دو آزمایه‌ی کاندید داریم که باید آزمایه‌ی بعدی را از بین این دو آزمایه انتخاب کنیم. لیست رفتارهایی که هر یک از این دو آزمایه مشاهده کرده‌اند در ادامه آمده است.

فرض کنید آزمایه‌ی شماره یک یک رشته‌ی خالی " " است و آزمایه شماره دو رشته \lr{"2+3"} است.

\end{itemize}
\begin{itemize}
	\item \textbf{اجرای آزمایه‌های کاندید}

حال دو آزمایه کاندید را روی سیستم تحت آزمون اجرا خواهیم کرد. رفتارهای مشاهده‌شده توسط این دو آزمایه کاندید به صورت زیر خواهد بود.

\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			evaluate &  \texttt{\lr{[]}} &  \lr{1} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه شماره یک در روش \lr{ART\_AutoISP}}
\end{table}




\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			evaluate &  \texttt{\lr{[evaluate.loop<line 6> $\rightarrow$ evaluate.loop<line 28>]}} &  \lr{1} \\
			\hline
			\multirow{2}{*}{ \lr{evaluate.loop<line 6>}} &  \texttt{\lr{[]}} &  \lr{1}  \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.loop<line 14>]}} &  \lr{2} \\
			\hline
			\lr{evaluate.loop<line 14>} &  \texttt{\lr{[]}} & \lr{2} \\
			\hline
			\lr{evaluate.loop<line 28>} &  \texttt{\lr{[process]}} & \lr{1} \\
			\hline
			\lr{process} &  \texttt{\lr{[apply\_operation]}} & \lr{1} \\
			\hline
			\lr{apply\_operation} &  \texttt{\lr{[]}} & \lr{1} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه شماره دو در روش \lr{ART\_AutoISP}}
\end{table}

\end{itemize}
\begin{itemize}
	\item \textbf{محاسبه امتیاز با توجه به رفتارهای مشاهده‌شده آزمایه‌های کاندید و رفتارهای مشاهده‌شده توسط مجموعه آزمایه‌های انتخاب‌شده قبلی}

هر آزمایه در طول اجرای خود، رفتارهایی را مشاهده خواهد کرد که هر چه این رفتارها توسط آزمایه‌های پیشین کمتر مشاهده شده باشند، ارزش بیشتری خواهند داشت و بالعکس. از طرف دیگر، اگر رفتاری در یک تابع فرضی به تعداد زیادی توسط آزمایه‌ها مشاهده شده باشد، نمی‌توان ادعا کرد که مشاهده این رفتار کاملاً بی‌ارزش است؛ زیرا رفتارهای تعریف‌شده در اینجا خلاصه‌ای از عملیات‌هایی است که توسط آن تابع به طور متوالی انجام شده‌اند. این بدان معناست که گاهی اوقات، با توجه به تعریف بیان‌شده در اینجا، دو رفتار کاملاً مشابه به نظر می‌رسند؛ اما ممکن است در جزئیات، تفاوت‌هایی داشته باشند. برای درک بهتر، فرض کنید تابع \lr{apply\_operation} دارای خطایی باشد که به ازای عملگر ضرب، عملیات جمع را انجام دهد.

\newpage
\begin{figure}[!h]
	\begin{LTR}
		\singlespacing
		\lstinputlisting[language=Python, caption={\footnotesize کد پایتون تابع apply\_operation}, firstnumber=45, label={code:pythonEx}]{apply_operation.py}
		% \doublespacing
	\end{LTR}
\end{figure}

تابع \lr{apply\_operation} فقط یک رفتار خالی (\lr{[]}) دارد، زیرا در بدنه‌ی خود حلقه‌ای ندارد و تابع دیگری را فراخوانی نمی‌کند. با این حال، در صورتی که ورودی‌هایی با عملگر ضرب (\lr{*}) داده شوند، این تابع دچار خطا می‌شود. بنابراین، توصیه می‌شود که امتیازهای دریافتی توسط آزمایه‌ها برای رفتارهای تکراری صفر نباشد تا بتوان اینگونه حالات را نیز مشاهده کرد.
برای امتیازدهی به آزمایه‌ها دو نکته‌ی زیر حائز اهمیت است:

\begin{itemize}
	\item هر چه تعداد دفعات مشاهده‌ی رفتارها توسط آزمایه‌ی کاندید، در مقایسه با آزمایه‌های قبلاً انتخاب شده، کمتر باشد، امتیاز بیشتری باید به آن آزمایه تعلق گیرد.
	\item اهمیت مشاهده‌ی رفتارهای تکراری وجود دارد و نباید برای مشاهده‌ی این دسته از رفتارها امتیازی در نظر گرفته نشود.
\end{itemize}

بنابراین، با توجه به دو نکته‌ی ذکر شده، فرمول پیشنهادی برای محاسبه امتیاز آزمایه‌های کاندید به شرح زیر است:
\[ \sum_{B} \sum_{i=1}^{n}\text{base}^{-(x+i)} \]

در این فرمول، برای محاسبه امتیاز هر آزمایه، برای هر رفتار \lr{(B)} که آزمایه در حین اجرا از سیستم تحت آزمون مشاهده می‌کند، امتیازی محاسبه می‌شود. در این فرمول، \( n \) تعداد دفعاتی است که رفتار توسط آزمایه پوشش داده شده است و \( \text{base} \) یک مقدار ثابت است که هرچه مقدار \( \text{base} \) بیشتر باشد، اهمیت پوشش رفتارهای تکراری کمتر خواهد بود. در اینجا مقدار متغیر \( \text{base} \) برابر با ۵ در نظر گرفته شده است. متغیر \( x \) نیز تعداد دفعاتی است که آن رفتار توسط آزمایه‌های انتخاب‌شده قبلی پوشش داده شده است. در نهایت، امتیاز نهایی هر آزمایه از مجموع امتیازاتی که به ازای هر رفتار به دست آورده است، محاسبه می‌شود. در ادامه با استفاده از این فرمول، امتیاز دو آزمایه در مثال قبل محاسبه شده است.

\begin{itemize}
	\item امتیاز آزمایه شماره یک
	\[ \sum_{B} \sum_{i=1}^{n} \text{base}^{-(x+i)} = (5^{-1}) = 0.2 \]
	\item امتیاز آزمایه شماره دو
	\begin{align*}
		\sum_{B} \sum_{i=1}^{n} \text{base}^{-(x+i)} & = (5^{-(10+1)}) + (5^{-(45+1)}) + (5^{-(12+1)} + 5^{-(12+2)})  + \\
		& (5^{-(48+1)} + 5^{-(48+2)}) + (5^{-(40+1)}) + (5^{-(104+1)}) + (5^{-(104+1)}) \\
		& \approx 0.00000002
	\end{align*}
\end{itemize}

\end{itemize}
\begin{itemize}
	\item \textbf{انتخاب آزمایه‌}

در نتیجه، آزمایه شماره یک از بین دو آزمایه کاندید انتخاب می‌شود و به مجموعه آزمایه‌های انتخاب شده اضافه می‌گردد. رفتارهای مشاهده شده توسط این آزمایه نیز به مجموعه رفتارهای مشاهده شده توسط آزمایه‌های پیشین افزوده خواهند شد.

همانطور که در جدول صفحه بعد می‌توان مشاهده کرد، رفتار \lr{[]} به مجموعه رفتارهای عنصر تکرارشونده \lr{evaluate} اضافه شده است.
\newpage
\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			\multirow{2}{*}{ \lr{evaluate}} &  \texttt{\lr{[evaluate.loop<line 6> $\rightarrow$ evaluate.loop<line 28>]}} &  \lr{10} \\
			\cline{2-3}
			&  \texttt{\textbf{\lr{[]}}} &  \textbf{\lr{1}} \\
			\hline
			\multirow{5}{*}{ \lr{evaluate.loop<line 6>}} &  \texttt{\lr{[]}} &  \lr{45}  \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.loop<line 14>]}} &  \lr{12} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.loop<line 20>]}} &  \lr{15} \\
			\cline{2-3}
			&  \texttt{\lr{[precedence $\rightarrow$ precedence]}} &  \lr{17} \\
			\cline{2-3}
			&  \texttt{\lr{[precedence $\rightarrow$ precedence $\rightarrow$ evaluate.loop<line 24>]}} &  \lr{11} \\
			\hline
			\lr{evaluate.loop<line 14>} &  \texttt{\lr{[]}} & \lr{48} \\
			\hline
			\lr{evaluate.loop<line 20>} &  \texttt{\lr{[process]}} & \lr{39} \\
			\hline
			\lr{evaluate.loop<line 24>} &  \texttt{\lr{[process]}} & \lr{23} \\
			\hline
			\lr{evaluate.loop<line 28>} &  \texttt{\lr{[process]}} & \lr{40} \\
			\hline
			\lr{precidence} &  \texttt{\lr{[]}} & \lr{56} \\
			\hline
			\lr{process} &  \texttt{\lr{[apply\_operation]}} & \lr{104} \\
			\hline
			\lr{apply\_operation} &  \texttt{\lr{[]}} & \lr{104} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه‌های انتخاب‌شده بعد از انتخاب آزمایه در روش \lr{ART\_AutoISP}}
\end{table}
\end{itemize}

در یک سناریوی دیگر، فرض کنید که هیچ آزمایه‌ای پیش از این انتخاب نشده بود. در این شرایط، امتیاز کسب‌شده توسط آزمایه ۲ بیشتر بود؛ زیرا آزمایه ۲ رفتارهای بیشتری را نسبت به آزمایه ۱ مشاهده کرده است، و هیچ‌یک از این رفتارها تاکنون مشاهده نشده بودند. در این وضعیت، آزمایه ۲ انتخاب می‌شد.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{روش \lr{ART\_AutoISP\_C}}
همان‌طور که پیش‌تر بیان شد، می‌توان تعاریف متنوعی از رفتار عناصر تکرارشونده (توابع و حلقه‌ها) ارائه داد. این روش، نگاهی متفاوت به تعریف رفتار این عناصر ارائه می‌دهد و تفاوت اصلی آن با روش \lr{ART\_AutoISP} در نحوه تعریف رفتار نهفته است. در روش \lr{ART\_AutoISP\_C}، هر ترتیب جدید از برآورده شدن شرایط موجود در کد برنامه تحت آزمون، به عنوان یک رفتار جدید برای هر عنصر تکرارشونده در نظر گرفته می‌شود.

%\subsubsection{توضیح روش با استفاده از مثال}

فرض کنید که برای کد مثال قبل توسط این روش، تعدادی آزمایه انتخاب شده است. با توجه به تعریف رفتار در این روش، رفتارهای زیر تاکنون توسط آزمایه‌های انتخاب شده مشاهده شده است.

\newpage
\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			evaluate &  \texttt{\lr{[evaluate.loop<line 6> $\rightarrow$ evaluate.loop<line 28>]}} &  \lr{10} \\
			\hline
			\multirow{8}{*}{ \lr{evaluate.loop<line 6>}} &  \texttt{\lr{[evaluate.condition<line 7>]}} &  \lr{11}  \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 10>]}} &  \lr{8} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 12>]}} &  \lr{12} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 12> $\rightarrow$ evaluate.loop<line 14>]}} &  \lr{12} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 19>]}} &  \lr{14} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 19> $\rightarrow$ evaluate.loop<line 20>]}} &  \lr{15} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 23>]}} &  \lr{17} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 23> $\rightarrow$ evaluate.loop<line 24>]}} &  \lr{11} \\
			\hline
			\lr{evaluate.loop<line 14>} &  \texttt{\lr{[]}} & \lr{48} \\
			\hline
			\lr{evaluate.loop<line 20>} &  \texttt{\lr{[]}} & \lr{39} \\
			\hline
			\lr{evaluate.loop<line 24>} &  \texttt{\lr{[]}} & \lr{23} \\
			\hline
			\lr{evaluate.loop<line 28>} &  \texttt{\lr{[]}} & \lr{40} \\
			\hline
			\multirow{2}{*}{\lr{precidence}} &  \texttt{\lr{[evaluate.condition<line 34>]}} & \lr{30} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 36>]}} &  \lr{26} \\
			\hline
			\lr{process} &  \texttt{\lr{[]}} & \lr{104} \\
			\hline
			\multirow{3}{*}{\lr{apply\_operation}} &  \texttt{\lr{[evaluate.condition<line 51>]}} & \lr{30} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 53>]}} &  \lr{42} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 55>]}} &  \lr{32} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه‌های انتخاب‌شده قبلی در روش \lr{ART\_AutoISP\_C}}
\end{table}

\begin{itemize}
	\item \textbf{تولید آزمایه‌های کاندید}
	
	برای انتخاب آزمایه جدید باید چند آزمایه کاندید جدید تولید شوند تا از بین این آزمایه‌ها بهترین آزمایه انتخاب شود.
	
	فرض کنید دو آزمایه‌ی کاندید در مثال قبل را داریم که باید آزمایه‌ی بعدی را از بین این دو آزمایه انتخاب کنیم. لیست رفتارهایی که هر یک از این دو آزمایه مشاهده کرده‌اند در ادامه آمده است.
	
	آزمایه‌ی شماره یک یک رشته‌ی خالی " " است و آزمایه شماره دو رشته \lr{"2+3"} است.
	
\end{itemize}
\begin{itemize}
\item \textbf{اجرای آزمایه‌های کاندید}

حال دو آزمایه کاندید را روی سیستم تحت آزمون اجرا خواهیم کرد. رفتارهای مشاهده‌شده توسط این دو آزمایه کاندید به صورت زیر خواهد بود.

\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			evaluate &  \texttt{\lr{[]}} &  \lr{1} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه شماره یک در روش \lr{ART\_AutoISP\_C}}
\end{table}

\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{9.1cm}|>{\footnotesize\centering\arraybackslash}m{1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			evaluate &  \texttt{\lr{[evaluate.loop<line 6> $\rightarrow$ evaluate.loop<line 28>]}} &  \lr{1} \\
			\hline
			\multirow{2}{*}{ \lr{evaluate.loop<line 6>}} &  \texttt{\lr{[evaluate.condition<line 23> → evaluate.loop<line 24>]}} &  \lr{1}  \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 12> → evaluate.loop<line 14>]}} &  \lr{2} \\
			\hline
			\lr{evaluate.loop<line 14>} &  \texttt{\lr{[]}} & \lr{2} \\
			\hline
			\lr{evaluate.loop<line 28>} &  \texttt{\lr{[]}} & \lr{1} \\
			\hline
			\lr{process} &  \texttt{\lr{[]}} & \lr{1} \\
			\hline
			\lr{apply\_operation} &  \texttt{\lr{[evaluate.condition<line 49>]}} & \lr{1} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه شماره دو در روش \lr{ART\_AutoISP\_C}}
\end{table}

\item \textbf{انتخاب آزمایه}

در اینجا می‌توان مشاهده کرد که آزمایه شماره دو رفتار \lr{[evaluate.condition<line 49>]} را برای اولین بار مشاهده کرد که تاکنون توسط آزمایه‌های انتخاب‌شده قبلی مشاهده نشده است (با این فرض که در هیچ‌یک از آزمایه‌های انتخاب‌شده قبلی از عملگر جمع (\lr{+}) استفاده نشده است). حال مجدداً امتیاز این دو آزمایه را با توجه به فرمول به دست می‌آوریم.

\begin{itemize}
	\item امتیاز آزمایه شماره یک
	\[ \sum_{B} \sum_{i=1}^{n} \text{base}^{-(x+i)} = (5^{-(0+1)}) = 0.2 \]
	\item امتیاز آزمایه شماره دو
	\begin{align*}
		\sum_{B} \sum_{i=1}^{n} \text{base}^{-(x+i)} & = (5^{-(10+1)}) + (5^{-(11+1)}) + (5^{-(12+1)} + 5^{-(12+2)})  + \\
		& (5^{-(48+1)} + 5^{-(48+2)}) + (5^{-(40+1)}) + (5^{-(104+1)}) + (5^{-(0+1)}) \\
		& \approx 0.20000002
	\end{align*}
\end{itemize}

در نتیجه، در این مثال آزمایه شماره دو از بین دو آزمایه کاندید انتخاب می‌شود و به مجموعه آزمایه‌های انتخاب‌شده اضافه می‌گردد. رفتارهای مشاهده‌شده توسط این آزمایه نیز به مجموعه رفتارهای مشاهده‌شده توسط آزمایه‌های قبلی اضافه خواهد شد.

\newpage
\begin{table}[H]
	\centering
	\begin{LTR}
		\begin{tabular}{|>{\arraybackslash\footnotesize}m{3.5cm}|>{\footnotesize\arraybackslash}m{8cm}|>{\footnotesize\centering\arraybackslash}m{2.1cm}|}
			\hline
			\textbf{\centering\rl{عنصر تکرارشونده}} & \textbf{ \centering\rl{رفتار}} & \textbf{\centering\rl{تعداد}} \\
			\hline
			evaluate &  \texttt{\lr{[evaluate.loop<line 6> $\rightarrow$ evaluate.loop<line 28>]}} &  \lr{10 + 1 = 11} \\
			\hline
			\multirow{8}{*}{ \lr{evaluate.loop<line 6>}} &  \texttt{\lr{[evaluate.condition<line 7>]}} &  \lr{11}  \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 10>]}} &  \lr{8} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 12>]}} &  \lr{12} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 12> $\rightarrow$ evaluate.loop<line 14>]}} &  \lr{12 + 2 = 14} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 19>]}} &  \lr{14} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 19> $\rightarrow$ evaluate.loop<line 20>]}} &  \lr{15} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 23>]}} &  \lr{17} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 23> $\rightarrow$ evaluate.loop<line 24>]}} &  \lr{11 + 1 = 12} \\
			\hline
			\lr{evaluate.loop<line 14>} &  \texttt{\lr{[]}} & \lr{48 + 2 = 50} \\
			\hline
			\lr{evaluate.loop<line 20>} &  \texttt{\lr{[]}} & \lr{39} \\
			\hline
			\lr{evaluate.loop<line 24>} &  \texttt{\lr{[]}} & \lr{23} \\
			\hline
			\lr{evaluate.loop<line 28>} &  \texttt{\lr{[]}} & \lr{40 + 1 = 41} \\
			\hline
			\multirow{2}{*}{\lr{precidence}} &  \texttt{\lr{[evaluate.condition<line 34>]}} & \lr{30} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 36>]}} &  \lr{26} \\
			\hline
			\lr{process} &  \texttt{\lr{[]}} & \lr{104 + 1 = 105} \\
			\hline
			\multirow{4}{*}{\lr{apply\_operation}} &  \texttt{\lr{[evaluate.condition<line 51>]}} & \lr{30} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 53>]}} &  \lr{42} \\
			\cline{2-3}
			&  \texttt{\lr{[evaluate.condition<line 55>]}} &  \lr{32} \\
			\cline{2-3}
			&  \textbf{\lr{[evaluate.condition<line 49>]}} &  \textbf{\lr{1}} \\
			\hline
		\end{tabular}
	\end{LTR}
	\caption{\footnotesize لیست رفتارهای مشاهده شده توسط آزمایه‌های انتخاب‌شده بعد از انتخاب آزمایه در روش \lr{ART\_AutoISP\_C}}
\end{table}

همانطور که مشاهده کردید، در این روش برخلاف روش قبلی، آزمایه اول به‌عنوان آزمایه برتر (آزمایه با امتیاز بیشتر) انتخاب شد. به عبارت دیگر، روش \lr{ART\_AutoISP\_C} نسبت به روش \lr{ART\_AutoISP} به جزییات بیشتری اهمیت می‌دهد و به همین دلیل معمولاً تعداد رفتارهایی که روش \lr{ART\_AutoISP\_C} نسبت به روش \lr{ART\_AutoISP} تشخیص می‌دهد، کمی بیشتر است. البته این افزایش تعداد رفتارها باعث افزایش هزینه فضایی و زمانی الگوریتم نیز خواهد شد.

البته دو آزمایه‌ای که به‌عنوان مثال در توضیح این دو روش استفاده شدند، هر دو آزمایه‌های با‌ارزشی هستند و نمی‌توان یکی را بر دیگری برتری داد، زیرا هر دوی این آزمایه‌ها قسمت‌هایی از کد سیستم تحت آزمون مثال بالا را پوشش می‌دهند که تاکنون پوشش داده نشده‌اند. در‌واقع، هدف از این مثال‌ها نمایش تفاوت عملکرد این دو روش بوده و نه برتری یکی از روش‌ها بر دیگری.

\end{itemize}

\subsubsection{حالت‌های دیگر از تعریف رفتار}

همان‌طور که مشاهده کردید، دو حالت مختلف از تعیین رفتار در بالا مورد بررسی قرار گرفت. با این‌حال، می‌توان تعاریف مختلفی از رفتار یک عنصر تکرارشونده (تابع‌ها و حلقه‌ها) ارائه کرد که در زیر به چند مورد دیگر اشاره شده است:
\begin{itemize}
	\item هر ترتیب جدید از پوشش شاخه‌ها \LTRfootnote{Branch} درون کد برنامه
	\item هر ترتیب جدید از مقداردهی متغیرهای درون کد برنامه
	\item هر ترتیب جدید از استفاده از مقدار متغیرهای درون کد برنامه
	\item هر ترتیب جدید از ترکیب رفتارهای مختلف (مثل هر ترتیب جدید از مقداردهی یا استفاده از مقدار متغیرهای درون کد برنامه)
	\item \dots
\end{itemize}
در همه این روش‌ها، بسته به اینکه چقدر در تعریف رفتار عمیق شده باشیم و حساسیت بیشتری به خرج داده باشیم، تعداد رفتارها متفاوت خواهد بود و این موضوع در هزینه اجرای الگوریتم تأثیرگذار است.



\subsection{تغییر تعریف میزان تفاوت بین آزمایه‌ها}

در فصل ۲، دو استراتژی معروف بیشترین-کمترین فاصله و بیشترین-مجموع فاصله از استراتژی‌های انتخاب آزمایه بر اساس فاصله بیان شده‌اند. همان‌طور که در مثال‌های بالا مشاهده کردید، در فرآیند انتخاب آزمایه از بین آزمایه‌های کاندید، آزمایه‌ای که بیشترین امتیاز را داشته باشد به‌عنوان بهترین آزمایه شناخته و انتخاب می‌شود. به عبارت دیگر، از استراتژی بیشترین امتیاز استفاده شده است.

در استراتژی‌های بیشترین-کمترین فاصله و بیشترین-مجموع فاصله، فاصله هر آزمایه کاندید با مجموعه آزمایه‌هایی که تاکنون انتخاب شده‌اند محاسبه می‌شود و سپس مقدار کمترین فاصله یا مجموع فاصله محاسبه شده و در نهایت، آزمایه‌ کاندیدی که بیشترین کمترین فاصله یا مجموع فاصله را داشته باشد، انتخاب می‌شود.

اما در استراتژی بیشترین امتیاز، امتیاز هر آزمایه کاندید با مقایسه رفتارهای مشاهده‌شده توسط آن آزمایه و مجموعه رفتارهای مشاهده‌شده توسط همه آزمایه‌هایی که تاکنون انتخاب شده‌اند محاسبه می‌شود و سپس آزمایه کاندیدی که بیشترین امتیاز را دارد، انتخاب خواهد شد.

از مقایسه این دو دسته استراتژی می‌توان به این استدلال رسید که در استراتژی بیشترین امتیاز، به‌جای محاسبه کمترین فاصله یا مجموع فاصله، امتیاز آزمایه استفاده می‌شود و این مزایا را به همراه دارد:

\begin{itemize}
	\item عدم نیاز به محاسبه فاصله با تک‌تک آزمایه‌های انتخاب‌شده در مراحل قبلی الگوریتم، در نتیجه هزینه زمانی کمتر نسبت به استراتژی‌های انتخاب آزمایه بر اساس فاصله
	\item عدم وابستگی هزینه زمانی انتخاب هر آزمایه به تعداد آزمایه‌های انتخاب‌شده در مراحل قبلی الگوریتم
	\item عدم نیاز به ذخیره نقاط متناظر آزمایه‌های انتخاب‌شده در مراحل قبلی الگوریتم و در نتیجه، هزینه فضایی کمتر نسبت به استراتژی‌های انتخاب آزمایه بر اساس فاصله
\end{itemize}


\subsubsection{تفاوت بین امتیاز و فاصله}

در ادامه به بررسی این موضوع می‌پردازیم که فاصله و امتیاز چه تفاوتی با هم دارند و چرا به جای کلمه «امتیاز» از کلمه «فاصله» استفاده نشده است، در حالی که از لحاظ معنایی هر دو برای نشان دادن میزان تفاوت بین آزمایه‌ها به‌کار می‌روند و مقدار آن‌ها با یکدیگر تقریباً رابطه مستقیم دارند. به‌طوری که هرچه فاصله بین یک آزمایه کاندید و مجموعه آزمایه‌های انتخاب‌شده قبلی بیشتر باشد، امتیاز آن آزمایه نیز بیشتر خواهد بود.

اولین شرطی که برای تعریف فاصله بین دو شیء از یک جنس باید در نظر داشت این است که تعریف فاصله به‌گونه‌ای باشد که فاصله هر شیء با خودش صفر باشد. اما در فرمول محاسبه امتیاز، هیچ‌گاه امتیاز یک آزمایه کاندید تکراری در مقایسه با آزمایه‌های انتخاب‌شده قبلی صفر نخواهد شد و تنها در صورتی به یک آزمایه امتیاز صفر تعلق می‌گیرد که هیچ‌یک از رفتارهای تعریف‌شده برای روش آزمون تصادفی تطبیقی مبتنی بر امتیازدهی را مشاهده نکرده باشد. به همین دلیل، نمی‌توان امتیاز را به عنوان فاصله بین دو آزمایه معرفی کرد.

\subsection{روال کلی روش‌های مبتنی بر امتیازدهی}

در ادامه، روال کلی این روش‌ها به‌صورت یک فلوچارت بیان شده است. 
در این فلوچارت، ابتدا ۱۰ آزمایه به‌صورت تصادفی تولید می‌شوند. سپس هر کدام از این آزمایه‌ها اجرا شده و امتیاز هر آزمایه براساس مقایسه رفتارهایی که آن آزمایه مشاهده می‌کند با رفتارهایی که تاکنون توسط آزمایه‌های انتخاب‌شده مشاهده شده‌اند، محاسبه می‌شود. آزمایه‌ای که بیشترین امتیاز را کسب کند، به‌عنوان بهترین آزمایه انتخاب‌شده و به مجموعه آزمایه‌های انتخاب‌شده اضافه خواهد شد. همچنین رفتارهای مشاهده‌شده توسط این آزمایه، به مجموعه رفتارهای مشاهده‌شده توسط آزمایه‌های انتخاب‌شده اضافه می‌شود، همان‌طور که در مثال‌های بالا توضیح داده شد. 
\newpage
\begin{figure}[H]
	\begin{tikzpicture}[node distance=2.5cm]
		
		\node (start) [startstop, text width=4cm, align=center] {\rl{شروع}};
		\node (process1) [process, below of=start, yshift=-0.2cm, text width=8cm, align=center] {\rl{تولید ۱۰ آزمایه شئ‌گرا جدید به عنوان مجموعه کاندید}};
		\node (process2) [process, below of=process1, yshift=-0.2cm, text width=8cm, align=center] {\rl{اجرای آزمایه‌های کاندید و امتیازدهی به آزمایه‌ها با توجه به رفتارهای مشاهده‌شده}};
		\node (process3) [process, below of=process2, yshift=-0.2cm, text width=8cm, align=center] {\rl{انتخاب آزمایه با بیشترین امتیاز (بهترین آزمایه)}};
		\node (process4) [process, below of=process3, yshift=-0.2cm, text width=8cm, align=center] {\rl{اضافه کردن آزمایه انتخاب شده به مجموعه آزمایه‌های انتخاب‌شده}};
		\node (process5) [process, below of=process4, yshift=-0.2cm, text width=8cm, align=center] {\rl{ اضافه کردن رفتارهای مشاهده‌شده توسط آزمایه انتخاب‌شده به مجموعه رفتارهای مشاهده‌شده}};
		\node (decision) [decision, below of=process5, yshift=-1cm, text width=2cm, align=center] {\rl{شرط خاتمه}};
		\node (output) [startstop, right of=decision, xshift=4cm, align=center] {\rl{خروجی آزمایه‌های تولید شده}};
		
		\draw [arrow] (start) -- (process1);
		\draw [arrow] (process1) -- (process2);
		\draw [arrow] (process2) -- (process3);
		\draw [arrow] (process3) -- (process4);
		\draw [arrow] (process4) -- (process5);
		\draw [arrow] (process5) -- (decision);
		\draw [arrow] (decision.west)  -| ++(-3.2, 0) |- node[anchor=east] {No} (process1.west);
		\draw [arrow] (decision) -- node[anchor=north] {Yes} (output);
	\end{tikzpicture}
	\caption{فلوچارت روش آزمون تصادفی تطبیقی مبتنی بر امتیازدهی}
\end{figure}



این فرآیند تا زمانی که شرط خاتمه برآورده شود، ادامه خواهد داشت. شرط خاتمه می‌تواند انتخاب تعداد مشخصی آزمایه یا یافتن خطا درون  سیستم تحت آزمون توسط آزمایه انتخاب شده یا هر معیار دیگر مرتبط با آزمون باشد.



\section{شباهت روش پیشنهادی با روش تقسیم‌بندی فضای ورودی}

همان‌طور که تاکنون توضیح داده شد، در روش پیشنهادی امتیازدهی آزمایه با توجه به رفتارهای مشاهده‌شده توسط آن آزمایه و رفتارهای مشاهده‌شده توسط مجموعه آزمایه‌های انتخاب‌شده انجام می‌شود. رفتارهای هر آزمایه درون عناصر تکرارشونده (تابع‌ها و حلقه‌ها) اهمیت بسیاری دارند و در روند امتیازدهی، بر اساس این رفتارها تلاش می‌شود که به رفتارهای کمتر مشاهده‌شده یا مشاهده‌نشده اهمیت بیشتری داده شود و امتیاز بیشتری به آزمایه‌های کاندیدی که این رفتارها را مشاهده می‌کنند، اختصاص یابد.

همان‌طور که در فصل ۲ توضیح داده شده، به‌طور مشابه در روش تقسیم‌بندی فضای ورودی که برای آزمون نرم‌افزار به صورت دستی استفاده می‌شود، آزمونگر بر اساس ویژگی‌های عملکردی و انواع مختلف ورودی‌های برنامه، چندین خصیصه تعریف می‌کند. هر کدام از این خصیصه‌ها دارای بخش‌بندی مخصوص به خود هستند که بخش‌بندی هر خصیصه باید شروط کامل بودن و عدم اشتراک را داشته باشد.

شباهت روش پیشنهادی در این پایان‌نامه با روش تقسیم‌بندی فضای ورودی، در شباهت بین عناصر تکرارشونده (تابع‌ها و حلقه‌ها) و رفتارهای هر عنصر تکرارشونده با خصیصه‌ها و بخش‌بندی هر خصیصه است. در واقع، در یک سیستم تحت آزمون می‌توان عناصر تکرارشونده را به عنوان خصیصه‌ها در نظر گرفت و رفتارهای هر عنصر تکرارشونده را به عنوان بخش‌بندی درون آن خصیصه. چرا که رفتارهای درون عناصر تکرارشونده نیز مانند بخش‌بندی درون هر خصیصه، شرط‌های کامل بودن و عدم اشتراک را دارند. همچنین از لحاظ معنا نیز هر رفتار جدید و متفاوت مشاهده‌شده برای هر عنصر تکرارشونده، به دلیل پوشش بخش‌های جدیدی از فضای ورودی است که تاکنون مشاهده نشده‌اند.

%در ادامه، برای نمایش بهتر شباهت بین این روش‌های انتخاب آزمایه بر اساس امتیاز و روش تقسیم‌بندی فضای ورودی، ابتدا به بررسی معنای عامیانه رفتارهای مشاهده‌شده توسط روش‌های انتخاب آزمایه بر مبنای امتیاز (که در مثال‌های فلان و فلان عنوان شده‌اند) پرداخته و سپس شباهت آن را با خصیصه‌های پیشنهادی ممکن توسط روش تقسیم‌بندی فضای ورودی بررسی خواهیم کرد.


\section{الگوریتم تشخیص خصیصه‌ها و بخش‌بندی‌ها}

برای پیاده‌سازی روش‌های آزمون تصادفی تطبیقی مبتنی بر امتیازدهی، لازم است که خصیصه‌ها و بخش‌بندی‌های هر خصیصه را با دنبال کردن\LTRfootnote{Tracing} فرآیند اجرای آزمایه‌ها به دست آوریم. برای تحقق این امر، مراحل زیر طی شده است تا خصیصه‌ها و بخش‌بندی‌های هر خصیصه را با توجه به تعریف آن‌ها استخراج کنیم.


الگوریتم تشخیص خصیصه‌ها و بخش‌بندی‌های هر خصیصه شامل دو مرحله کلی است که در ادامه توضیح داده شده است.

برای نمونه، نحوه به دست آوردن خصیصه‌ها و بخش‌بندی‌های هر خصیصه در روش \lr{ART\_AutoISP} شرح داده شده است و چگونگی تعمیم این روش به سایر استراتژی‌های تعریف خصیصه‌ها و بخش‌بندی‌ها نیز بررسی شده است.

\begin{itemize}
	\item\textbf{مرحله اول}

با توجه به تعریف خصیصه‌ها و بخش‌بندی‌های هر خصیصه در روش ART\_AutoISP ، عملیات‌های فراخوانی یک تابع جدید و وارد شدن درون حلقه‌ها در تعریف خصیصه‌ها و بخش‌بندی‌های آن‌ها اهمیت دارد و باید این عملیات‌ها در فرآیند اجرای آزمایه‌ها دنبال شده و به ترتیب ثبت شوند. برای این منظور، در این پژوهش یک کپی از سیستم تحت آزمون گرفته شده و سپس در کپی سیستم تحت آزمون، بخش‌های مورد نظر مانند خط اول تابع‌ها و خط اول حلقه‌ها (برای عملیات فراخوانی تابع یا ورود به حلقه) به‌صورت دستی، تابع‌های کلاس ضبط کننده\LTRfootnote{Recorder} فراخوانی شده است.

برای مثال، در کد سیستم تحت آزمون برنامه ۳.۱، درون تابع evaluate ، این دستورات به‌صورت دستی به کد اضافه شده‌اند و درون یک کلاس ضبط کننده با استفاده از پشته اجرا\LTRfootnote{StackTraceElement}، مواردی از قبیل آدرس تابع انجام‌دهنده عملیات، نوع عملیات (فراخوانی تابع یا پوشش حلقه) و همچنین شماره خطی که عملیات در آن انجام شده است، به‌عنوان یک عملیات جدید ثبت و درون یک لیست ذخیره می‌شوند.

\newpage
\begin{figure}[!h]
	\begin{LTR}
		\singlespacing
		\lstinputlisting[language=Python, caption={\footnotesize کد پایتون برای محاسبه یک عبارت ریاضی}, label={code:pythonEx}]{evaluate.py}
		% \doublespacing
	\end{LTR}
\end{figure}

به همین ترتیب، برای روش ART\_AutoISP\_C که پوشش شرط‌ها نیز اهمیت دارد، علاوه بر خطوطی که در روش ART\_AutoISP توابع کلاس ضبط کننده فراخوانی شدند، در خط اول هر شرط نیز تابع \lr{condition\_passed()} از کلاس ضبط کننده فراخوانی می‌شود.

	\item \textbf{مرحله دوم}

با توجه به توضیحات داده‌شده، خروجی مرحله اول، یک لیست از عملیات‌های انجام‌شده در حین اجرای آزمایه خواهد بود. در مرحله دوم، پس از اجرای آزمایه، با استفاده از لیست عملیات‌هایی که آزمایه در حین اجرای خود به ترتیب انجام داده است و در مرحله اول الگوریتم ثبت شده است، خصیصه‌ها و بخش‌بندی‌های آن‌ها محاسبه می‌شوند.

\end{itemize}

